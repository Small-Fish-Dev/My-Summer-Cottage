@namespace Sauna.UI
@using Sauna.Event
@attribute [StyleSheet]
@inherits Panel

@if ( !HasTarget )
	return;

<root>
	@if ( !FromHold )
	{
		<image src="ui/hud/interaction-pointer.png" class="icon" />
	}

	<div class="content">
		<text class="title">@_targetObject.Name</text>

		<div class="interactions">
			@foreach(var interaction in _interactions)
			{
				if ( !FromHold && interaction.HoldOnly )
					continue;

				if ( CanInteract( interaction ) )
				{
					<div class="interaction">
						<inputhint class="hint" input=@interaction.Keybind />
						<text class="description">@interaction.Text</text>
					</div>
				}
			}
		</div>
	</div>
</root>

@code {
	public bool FromHold { get; set; }

	private GameObject _targetObject => FromHold
		? Player.Local?.Inventory?.EquippedItems?[(int)EquipSlot.Hand]?.GameObject
		: Player.Local?.TargetedGameObject;

	private bool HasTarget => _targetObject is not null;

	private IEnumerable<Interaction> _interactions => _targetObject?.GetInteractions() ?? new List<Interaction>();
    private Vector2 _lerpPosition;

    private bool CanInteract( Interaction interaction )
        => (interaction.Disabled is null || !interaction.Disabled())
        && (!interaction.HasBounds || GetInteractionBounds(interaction).Contains(Player.Local.InteractionTrace.EndPosition));

    private BBox GetInteractionBounds(Interaction interaction)
        => new BBox(interaction.Position - interaction.Extents / 2f, interaction.Position + interaction.Extents / 2f)
            .Transform(Player.Local.TargetedGameObject.Transform.World);

    public override void Tick() 
    {
        SetClass("visible", HasTarget);

        if (!HasTarget)
            return;

        var pos = FromHold ? 0 : Player.Local.TargetedGameObject.Transform.Position + Player.Local.InteractionBounds?.Center ?? 0;
        foreach ( var interaction in _interactions )
        {
			if ( !FromHold && interaction.HoldOnly )
				continue;

            if ( CanInteract( interaction ) )
            {
                if ( interaction.HasBounds && !FromHold )
                    pos = Player.Local.TargetedGameObject.Transform.Position + interaction.Position * Player.Local.TargetedGameObject.Transform.Rotation;

                if ( interaction.InputFunction( interaction.Keybind ) )	
                {
					_targetObject?.Network.TakeOwnership();
					interaction.Action?.Invoke(Player.Local, _targetObject);

                    if ( interaction.Identifier != String.Empty )
                      EventSystem.InteractionInvoked( interaction.Identifier, _targetObject.Id, Player.Local.GameObject.Id ); // Pass off this interaction for events to find

					if ( !FromHold ) // No need to play use animation for held items.
					{
						var vector = (pos - Player.Local.Transform.Position) * Player.Local.Transform.Rotation.Inverse;
						Player.Local.BroadcastInteraction( vector, Rotation.LookAt( vector.Normal ) );
					}
				}
			}
		}

		if ( FromHold ) // No need to play use animation for held items.
			return;

		_lerpPosition = Vector2.Lerp( _lerpPosition, pos.ToScreen().Clamp( -0.5f, 1.5f ), 10f * Time.Delta );
        Style.Left = Length.Fraction( MathF.Floor( _lerpPosition.x * 200f + 0.5f ) / 200f );
        Style.Top = Length.Fraction( MathF.Floor( _lerpPosition.y * 200f + 0.5f ) / 200f );
	}

	protected override int BuildHash()
	{
		return HashCode.Combine(HasTarget, _targetObject?.Name, _interactions.HashCombine(i => HashCode.Combine(i.Text, CanInteract(i))));
	}
}
