@namespace Sauna.UI
@using Sauna.Event
@attribute [StyleSheet]
@inherits Panel

<root>
	@if ( !FromHands )
	{
		<image src="ui/hud/interaction-pointer.png" class="icon" />
	}

	<div class="content">
		<text class="title">@DisplayName</text>
		<div class="interactions">
			@foreach(var interaction in _interactions)
			{
				if (interaction is null || !WithinBounds(interaction) || !IsAccessible(interaction) )
					continue;

                var coolDown = !interaction.Cooldown || interaction.CooldownTimer;
                var canInteract = !interaction.Disabled.InvokeOrDefault() && coolDown && !Player.Local.BlockInputs;

				if ( canInteract || interaction.ShowWhenDisabled() )
				{
                    var isActive = HasPriority(interaction.Keybind) && canInteract;
					<div class="interaction">
						<div>
							<inputhint class="hint" input=@interaction.Keybind DarkMode=@(!isActive) />
							<text class="description" style="color: @(isActive ? @interaction.Color.Hex : "#883232")">@interaction.Text</text>
						</div>

						@if( interaction.Cooldown && !interaction.CooldownTimer )
						{
							<img class="circle" src="ui/hud/circle/circle_@(TimerIndex(interaction)).png" />
						}
					</div>
				}
			}
		</div>
	</div>
</root>

@code {
	public bool FromHands { get; set; }

	// TODO: Gamejam code.
	private string DisplayName => _targetObject?.Components?.Get<ItemComponent>()?.Name ?? _targetObject?.Components?.Get<DialogueTree>()?.Name ?? _targetObject?.Name;
	private GameObject _targetObject => FromHands
		? Player.Local?.Inventory?.EquippedItems?[(int)EquipSlot.Hand]?.GameObject
		: Player.Local?.TargetedGameObject;

	private static Dictionary<string, Interaction> priorityList = new();
	private IEnumerable<Interaction> _interactions => _targetObject?.GetInteractions() ?? new List<Interaction>();
	private bool WithinBounds(Interaction interaction) => !interaction.HasBounds || GetInteractionBounds(interaction).Contains(Player.Local.InteractionTrace.EndPosition);
	private bool HasPriority( string key ) => FromHands || !priorityList.ContainsKey( key.ToLower() );
	private BBox GetInteractionBounds(Interaction interaction)
		=> new BBox(interaction.Position - interaction.Extents / 2f, interaction.Position + interaction.Extents / 2f)
			.Transform(Player.Local.TargetedGameObject.Transform.World);

	private int TimerIndex( Interaction interaction )
		=> (int)(MathX.Remap( interaction.CooldownTimer.Passed, 0, interaction.CooldownTime, 8, 0 ) + 0.5f);

	private void AddToPriority( Interaction interaction, bool forced = false )
	{
		if ( !FromHands && !forced ) 
			return;

		var key = interaction.Keybind.ToLower();
		var contains = priorityList.ContainsKey( key );
		if ( contains ) 
			return;

		priorityList.Add( key, interaction );
	}

	public override void Tick() 
	{	
		if ( FromHands ) priorityList.Clear();

		SetClass( "visible", ShowHint() );
		if (!HasClass("visible"))
			return;

		var pos = FromHands ? 0 : (Player.Local.InteractionBounds == null ? Player.Local.TargetedGameObject.Transform.Position : Player.Local.TargetedGameObject.Transform.World.PointToWorld( Player.Local.InteractionBounds.Value.Center ) );

		foreach ( var interaction in _interactions )
		{
			if ( interaction is null || !WithinBounds(interaction) || !IsAccessible(interaction) )
				continue;

			var canInteract = !interaction.Disabled.InvokeOrDefault();
			if ( canInteract )
				AddToPriority( interaction );

			if ( !HasPriority( interaction.Keybind ) )
				continue;

			if ( interaction.HasBounds && !FromHands )
				pos = Player.Local.TargetedGameObject.Transform.Position + interaction.Position * Player.Local.TargetedGameObject.Transform.Rotation;

			var coolDown = !interaction.Cooldown || interaction.CooldownTimer;

			if (canInteract && interaction.InputFunction(interaction.Keybind) && coolDown && !Player.Local.BlockInputs)
			{
				_targetObject?.Network.TakeOwnership();
				interaction.Action?.Invoke(Player.Local, _targetObject);

				interaction.CooldownTimer = interaction.CooldownTime;

				@* For some reason need another null check here :/ *@
				if (!_targetObject.IsValid())
					return;

				if (interaction.InputMode != InputMode.Down)
					Input.Clear(interaction.Keybind);

				if ( interaction.Identifier != String.Empty )
					EventMaster.InteractionInvoked( interaction.Identifier, _targetObject.Id, Player.Local.GameObject.Id ); // Pass off this interaction for events to find

				var vector = (pos - Player.Local.Transform.Position) * Player.Local.Transform.Rotation.Inverse;
				Player.Local.BroadcastInteraction( 
					vector, 
					Rotation.LookAt( vector.Normal ), 
					interaction.Animation, 
					_targetObject.Id, 
					interaction.Sound?.InvokeOrDefault()?.ResourceId ?? -1,
					interaction.PlaySoundFromPlayer
				);
			}
		}

		if ( FromHands ) // No need to play use animation for held items.
			return;

		pos = Scene.Camera.PointToScreenPixels( pos );
		pos *= ScaleFromScreen;

		Style.Position = PositionMode.Absolute;
		Style.Left = Length.Pixels( pos.x );
        Style.Top = Length.Pixels( pos.y );
        
        StateHasChanged();
	}

	private bool ShowHint()
	{
		if (!_targetObject.IsValid())
			return false;

		if (!_targetObject.Components.TryGet<Interactions>( out var interactions ))
			return false;

		var interactionsAvailable = interactions.AllInteractions.Any( i => WithinBounds(i) && WithinRange(i) );
		if (!interactionsAvailable && interactions.HideOnEmpty)
			return false;

		return interactionsAvailable;
	}

	private bool IsAccessible(Interaction interaction)
	{
		if (FromHands && interaction.Accessibility.HasFlag(AccessibleFrom.Hands))
			return true;
		
		if (!FromHands && interaction.Accessibility.HasFlag(AccessibleFrom.World))
			return true;

		return false;
	}

	private bool WithinRange(Interaction interaction)
	{
		return FromHands || Player.Local.ViewRay.Position.Distance(_targetObject.Transform.Position) < interaction.InteractDistance;
	}

	protected override int BuildHash()
	{
		return HashCode.Combine
		(
			DisplayName, 
			_targetObject.IsValid(),
			_interactions.HashCombine(i => HashCode.Combine(i.Text, i.Disabled.InvokeOrDefault(), (bool)i.CooldownTimer, TimerIndex(i), WithinBounds(i), HasPriority(i.Keybind)))
		);
	}
}
