@namespace Sauna.UI
@using Sauna.Event
@attribute [StyleSheet]
@inherits Panel

<root>
	@if ( !FromHands )
	{
		<image src="ui/hud/interaction-pointer.png" class="icon" />
	}

	<div class="content">
		<text class="title">@DisplayName</text>
		<div class="interactions">
			@foreach(var interaction in _interactions)
			{
				if ( !WithinBounds(interaction) || !IsAccessible(interaction) )
					continue;

				var canInteract = !interaction.Disabled.InvokeOrDefault();
				if ( canInteract || interaction.ShowWhenDisabled() )
				{
					var isActive = HasPriority( interaction.Keybind ) && canInteract;
					<div class="interaction">
						<inputhint class="hint" input=@interaction.Keybind DarkMode=@(!isActive) />
						<text class="description" style="color: @(isActive ? @interaction.Color.Hex : "#883232")">@interaction.Text</text>
					</div>
				}
			}
		</div>
	</div>
</root>

@code {
	public bool FromHands { get; set; }

	private string DisplayName => _targetObject?.Components?.Get<ItemComponent>()?.Name ?? _targetObject?.Name;
	private GameObject _targetObject => FromHands
		? Player.Local?.Inventory?.EquippedItems?[(int)EquipSlot.Hand]?.GameObject
		: Player.Local?.TargetedGameObject;

	private static Dictionary<string, Interaction> priorityList = new();
	private IEnumerable<Interaction> _interactions => _targetObject?.GetInteractions() ?? new List<Interaction>();
	private bool WithinBounds(Interaction interaction) => !interaction.HasBounds || GetInteractionBounds(interaction).Contains(Player.Local.InteractionTrace.EndPosition);
	private bool HasPriority( string key ) => FromHands || !priorityList.ContainsKey( key.ToLower() );
	private BBox GetInteractionBounds(Interaction interaction)
		=> new BBox(interaction.Position - interaction.Extents / 2f, interaction.Position + interaction.Extents / 2f)
			.Transform(Player.Local.TargetedGameObject.Transform.World);

	private void AddToPriority( Interaction interaction, bool forced = false )
	{
		if ( !FromHands && !forced ) 
			return;

		var key = interaction.Keybind.ToLower();
		var contains = priorityList.ContainsKey( key );
		if ( contains ) 
			return;

		priorityList.Add( key, interaction );
	}

	public override void Tick() 
	{	
		if ( FromHands ) priorityList.Clear();

		SetClass( "visible", ShowHint() );
		if (!HasClass("visible"))
			return;

		var pos = FromHands ? 0 : Player.Local.TargetedGameObject.Transform.Position + Player.Local.InteractionBounds?.Center ?? 0;
		foreach ( var interaction in _interactions )
		{
			if ( !WithinBounds(interaction) || !IsAccessible(interaction) )
				continue;

			var canInteract = !interaction.Disabled.InvokeOrDefault();
			if ( canInteract )
				AddToPriority( interaction );

			if ( !HasPriority( interaction.Keybind ) )
				continue;

			if ( interaction.HasBounds && !FromHands )
				pos = Player.Local.TargetedGameObject.Transform.Position + interaction.Position * Player.Local.TargetedGameObject.Transform.Rotation;

			if (canInteract && interaction.InputFunction(interaction.Keybind))
			{
				_targetObject?.Network.TakeOwnership();
				interaction.Action?.Invoke(Player.Local, _targetObject);

				if (interaction.InputMode != InputMode.Down)
					Input.Clear(interaction.Keybind);

				if ( interaction.Identifier != String.Empty )
					EventMaster.InteractionInvoked( interaction.Identifier, _targetObject.Id, Player.Local.GameObject.Id ); // Pass off this interaction for events to find

				var vector = (pos - Player.Local.Transform.Position) * Player.Local.Transform.Rotation.Inverse;
				Player.Local.BroadcastInteraction( vector, Rotation.LookAt( vector.Normal ), interaction.Animation );
			}
		}

		if ( FromHands ) // No need to play use animation for held items.
			return;

		pos = pos.ToScreen().Clamp( -0.5f, 1.5f );
        Style.Left = Length.Fraction( MathF.Floor( pos.x * 200f + 0.5f ) / 200f );
        Style.Top = Length.Fraction( MathF.Floor( pos.y * 200f + 0.5f ) / 200f );
	}

	private bool ShowHint()
	{
		if (!_targetObject.IsValid())
			return false;

		if (!_targetObject.Components.TryGet<Interactions>( out var interactions ))
			return false;

		var interactionsAvailable = interactions.AllInteractions.Any( i => WithinBounds(i) && WithinRange(i) );
		if (!interactionsAvailable && interactions.HideOnEmpty)
			return false;

		return interactionsAvailable;
	}

	private bool IsAccessible(Interaction interaction)
	{
		if (FromHands && interaction.Accessibility.HasFlag(AccessibleFrom.Hands))
			return true;
		
		if (!FromHands && interaction.Accessibility.HasFlag(AccessibleFrom.World))
			return true;

		return false;
	}

	private bool WithinRange(Interaction interaction)
	{
		return FromHands || Player.Local.ViewRay.Position.Distance(_targetObject.Transform.Position) < interaction.InteractDistance;
	}

	protected override int BuildHash()
	{
		return HashCode.Combine
		(
			DisplayName, 
			_targetObject.IsValid(),
			_interactions.HashCombine(i => HashCode.Combine(i.Text, i.Disabled.InvokeOrDefault(), WithinBounds(i), HasPriority(i.Keybind)))
		);
	}
}
