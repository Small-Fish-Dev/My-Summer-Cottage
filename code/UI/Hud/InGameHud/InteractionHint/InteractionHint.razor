@namespace Sauna.UI
@using Sauna.Event
@attribute [StyleSheet]
@inherits Panel

<root>
	@if ( !FromHold )
	{
		<image src="ui/hud/interaction-pointer.png" class="icon" />
	}

	<div class="content">
		<text class="title">@Name</text>

		<div class="interactions">
			@foreach(var interaction in _interactions)
			{
				if ( !FromHold && interaction.HoldOnly )
					continue;

				if (!WithinBounds(interaction))
					continue;

				var canInteract = CanInteract( interaction );
				if ( canInteract || (interaction.ShowWhenDisabled is not null && interaction.ShowWhenDisabled()) )
				{
					var inactive = !HasPriority( interaction.Keybind ) || !canInteract;
					<div class="interaction">
						<inputhint class="hint" input=@interaction.Keybind DarkMode=@inactive />
						<text class="description" style="color: @interaction.Color.Hex">@interaction.Text</text>
					</div>
				}
			}
		</div>
	</div>
</root>

@code {
	public bool FromHold { get; set; }

	private GameObject _targetObject => FromHold
		? Player.Local?.Inventory?.EquippedItems?[(int)EquipSlot.Hand]?.GameObject
		: Player.Local?.TargetedGameObject;

	private string Name => _targetObject?.Components?.Get<ItemComponent>()?.Name ?? _targetObject?.Name;
	private bool HasTarget => _targetObject is not null;

	// We should clean this up!!
	private bool ShouldHide => 
		(_targetObject?.Components?.Get<Interactions>( FindMode.EverythingInSelf )?.HideOnEmpty ?? false)
		&& !(_interactions?.Any( i => (CanInteract( i ) || (i.ShowWhenDisabled is not null && i.ShowWhenDisabled())) && WithinBounds( i ) ) ?? false);

	private const float INTERACTION_COOLDOWN = 0.1f;
	private static List<string> priorityList = new();
	private IEnumerable<Interaction> _interactions => _targetObject?.GetInteractions() ?? new List<Interaction>();
	private static TimeSince _lastInteracted;

	public InteractionHint()
	{
		_lastInteracted = 0f;
	}

	private bool CanInteract(Interaction interaction)
		=> interaction.Disabled is null || !interaction.Disabled();

	private bool WithinBounds(Interaction interaction)
		=> !interaction.HasBounds || GetInteractionBounds(interaction).Contains(Player.Local.InteractionTrace.EndPosition);

	private bool HasPriority( string key )
		=> FromHold || !priorityList.Contains( key.ToLower() );

	private BBox GetInteractionBounds(Interaction interaction)
		=> new BBox(interaction.Position - interaction.Extents / 2f, interaction.Position + interaction.Extents / 2f)
			.Transform(Player.Local.TargetedGameObject.Transform.World);

	private void AddToPriority( string key, bool forced = false )
	{
		if ( !FromHold && !forced ) 
			return;

		key = key.ToLower();
		var contains = priorityList.Contains( key );
		if ( contains ) 
			return;

		priorityList.Add( key );
	}

	public override void Tick() 
	{
		if ( FromHold ) priorityList.Clear();

		SetClass( "visible", HasTarget && !ShouldHide );
		if (!HasClass("visible"))
			return;

		var pos = FromHold ? 0 : Player.Local.TargetedGameObject.Transform.Position + Player.Local.InteractionBounds?.Center ?? 0;
		foreach ( var interaction in _interactions )
		{
			if ( !FromHold && interaction.HoldOnly )
				continue;

			if ( WithinBounds( interaction ) )
			{
				var canInteract = CanInteract(interaction);

				if ( canInteract )
					AddToPriority( interaction.Keybind );

				if ( !HasPriority( interaction.Keybind ) )
					continue;

				if ( interaction.HasBounds && !FromHold )
					pos = Player.Local.TargetedGameObject.Transform.Position + interaction.Position * Player.Local.TargetedGameObject.Transform.Rotation;

				if (canInteract && interaction.InputFunction(interaction.Keybind) && (interaction.InputMode == InputMode.Down || _lastInteracted > INTERACTION_COOLDOWN))
				{
					_targetObject?.Network.TakeOwnership();
					interaction.Action?.Invoke(Player.Local, _targetObject);
					_lastInteracted = 0f;

					if ( interaction.Identifier != String.Empty )
						EventMaster.InteractionInvoked( interaction.Identifier, _targetObject.Id, Player.Local.GameObject.Id ); // Pass off this interaction for events to find

					if ( !FromHold ) // No need to play use animation for held items.
					{
						var vector = (pos - Player.Local.Transform.Position) * Player.Local.Transform.Rotation.Inverse;
						Player.Local.BroadcastInteraction( vector, Rotation.LookAt( vector.Normal ), interaction.DisableUseAnimation );
					}
				}
			}
		}

		if ( FromHold ) // No need to play use animation for held items.
			return;

		pos = pos.ToScreen().Clamp( -0.5f, 1.5f );
        Style.Left = Length.Fraction( MathF.Floor( pos.x * 200f + 0.5f ) / 200f );
        Style.Top = Length.Fraction( MathF.Floor( pos.y * 200f + 0.5f ) / 200f );
	}

	protected override int BuildHash()
	{
		return HashCode.Combine(HasTarget, Name, _interactions.HashCombine(i => HashCode.Combine(i.Text, CanInteract(i), WithinBounds(i), HasPriority(i.Keybind))));
	}
}
